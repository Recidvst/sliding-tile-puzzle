{"version":3,"sources":["app.js"],"names":["guidGenerator","S4","Math","random","toString","substring","shuffleArray","array","i","length","j","floor","shuffleItems","list","children","appendChild","resetGrid","oldTiles","ul","item","classList","remove","setOpenTile","tiles","add","setImagePositions","container","parentElement","forEach","tile","style","backgroundSize","offsetWidth","offsetHeight","backgroundPosition","offsetLeft","offsetTop","setMemory","memObj","index","getAttribute","puzzleCompleteCheck","memory","result","document","querySelectorAll","every","tileID","isSpaceFree","parseFloat","contains","recursiveFindLowest","currentTiles","cur","sqrt","recursiveFindHighest","swapTiles","currentIndex","swapIndex","querySelector","tileContainer","obj1","obj2","temp","swap","swapItemOne","swapItemTwo","createElement","parentNode","insertBefore","removeChild","triggerTileMovement","thisTile","findIndex","id","root","movementStatuses","checkTopPromise","Promise","resolve","then","results","top","allow","catch","err","console","error","checkBottomPromise","bottom","checkLeftPromise","leftTile","left","checkRightPromise","rightTile","right","all","Object","keys","constructor","property","window","addEventListener","startTiles","startButton","getElementById","resetButton","e","target","setTimeout","alert","hasAttribute","setAttribute","removeAttribute"],"mappings":"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","file":"app.js","sourceRoot":"..\\js","sourcesContent":["// id generator\r\nfunction guidGenerator() {\r\n  var S4 = function() {\r\n     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\r\n  };\r\n  return (S4()+S4());\r\n}\r\n\r\n// random shufflers\r\nfunction shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\nfunction shuffleItems(list) {\r\n\tfor (var i = list.children.length; i >= 0; i--) {\r\n\t\t\tlist.appendChild(list.children[Math.random() * i | 0]);\r\n\t}\r\n}\r\n\r\n// reset grid\r\nfunction resetGrid(oldTiles, list) {\r\n\tconst ul = list;\r\n\tfor (var i = 0; i <= ul.children.length -1; i++) {\r\n\t\tconst item = oldTiles[i];\r\n\t\titem.classList.remove('open');\r\n\t\tul.appendChild(item);\r\n\t}\r\n}\r\n\r\n// set open tile\r\nfunction setOpenTile(tiles) {\r\n\tconst rand = Math.floor(Math.random() * tiles.length);\r\n\ttiles[rand].classList.add('open');\r\n}\r\n\r\n// set background positions\r\nfunction setImagePositions(tiles) {\r\n\tconst container = tiles[0].parentElement; // tile-container\r\n\ttiles.forEach( (tile) => {\r\n\t\t// set image size\r\n\t\ttile.style.backgroundSize = `${container.offsetWidth}px ${container.offsetHeight}px`;\r\n// \t\tset image position\r\n\t\ttile.style.backgroundPosition = `-${tile.offsetLeft}px -${tile.offsetTop}px`;\r\n\t});\r\n}\r\n\r\n// setting memory\r\nfunction setMemory(tiles) {\r\n\tlet memObj = {};\r\n\ttiles.forEach( (tile, index) => {\r\n\t\tmemObj[tile.getAttribute('id')] = {\r\n\t\t\t'index' : index,\r\n\t\t\t'id' : tile.getAttribute('id')\r\n\t\t};\r\n\t});\r\n\treturn memObj; // returns memory object\r\n}\r\n\r\n// check against memory to confirm complete\r\nfunction puzzleCompleteCheck(memory) {\r\n\tconst tiles = [...document.querySelectorAll('.tile')];\r\n\tconst result = tiles.every( (tile, index) => {\r\n\t\t// check if current position matches first position for all tiles\r\n\t\tconst tileID = tile.getAttribute('id');\r\n\t\treturn index === memory[tileID].index;\r\n\t});\r\n\treturn result;\r\n}\r\n\r\n// check if the specified space is free\r\nfunction isSpaceFree(index) {\r\n\tif (index === false ) return false;\r\n\tconst currentTiles = [...document.querySelectorAll('.tile')];\r\n\tconst ind = Math.floor(parseFloat(index)) - 1;\r\n\tif (currentTiles[ind].classList.contains('open')) {\r\n\t\t\treturn {\r\n\t\t\t\t'result': true,\r\n\t\t\t\t'index': Math.floor(parseFloat(index)),\r\n\t\t\t};\r\n\t}\r\n\treturn {\r\n\t\t\t\t'result': false,\r\n\t\t\t\t'index': Math.floor(parseFloat(index)),\r\n\t};\r\n}\r\n\r\n// functions to check if adjacent squares are on the same row or wrapped (e.g. shouldn't move to wrapped adjacent tiles!)\r\nfunction recursiveFindLowest(index, currentTiles) {\r\n\t// keep taking the width of the row away from the current index until we hit below zero\r\n\t// when can't go any lower, test the index value\r\n\t// if this equals 1 (first tile), then the original tile was the left-most in it's row and so shouldn't accept left movements\r\n\tlet cur = index - Math.sqrt(currentTiles.length);\r\n\tif (cur >= 0) {\r\n\t\t\treturn recursiveFindLowest(cur, currentTiles);\r\n\t}\r\n\telse {\r\n\t\t\tif (index === 1) {\r\n\t\t\t\t\treturn false; // this means its a left edge and so not allowed\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t}\r\n}\r\nfunction recursiveFindHighest(index, currentTiles) {\r\n\t// keep adding the width of the row away to the current index until we hit below the number of total tiles\r\n\t// when can't go any higher, test the index value\r\n\t// if this equals the total number of tiles, then the original tile was the right-most in it's row and so shouldn't accept right movements\r\n\tlet cur = index + Math.sqrt(currentTiles.length);\r\n\tif (cur <= currentTiles.length) {\r\n\t\t\treturn recursiveFindHighest(cur, currentTiles);\r\n\t}\r\n\telse {\r\n\t\t\tif (index === currentTiles.length) {\r\n\t\t\t\t\treturn false; // this means its a right edge and so not allowed\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t}\r\n}\r\n\r\n// movement functionality fn\r\nfunction swapTiles(currentIndex, swapIndex) {\r\n\t// container and tiles\r\n\tconst tileContainer = document.querySelector('.tile-container');\r\n\tconst currentTiles = [...document.querySelectorAll('.tile')];\r\n\t// reset to zero indexed\r\n\tconst current = currentIndex - 1;\r\n\tconst swap = swapIndex - 1;\r\n\t// items to swap\r\n\tlet swapItemOne = currentTiles[current];\r\n\tlet swapItemTwo =  currentTiles[swap];\r\n\t// fn\r\n\tfunction swapElements(obj1, obj2) {\r\n    // create marker element and insert it where obj1 is\r\n    var temp = document.createElement(\"div\");\r\n    obj1.parentNode.insertBefore(temp, obj1);\r\n    // move obj1 to right before obj2\r\n    obj2.parentNode.insertBefore(obj1, obj2);\r\n    // move obj2 to right before where obj1 used to be\r\n    temp.parentNode.insertBefore(obj2, temp);\r\n    // remove temporary marker node\r\n\t\ttemp.parentNode.removeChild(temp);\r\n\t}\r\n\tswapElements(swapItemOne, swapItemTwo);\r\n}\r\n\r\n// movement trigger fn\r\nfunction triggerTileMovement(thisTile, currentTiles) {\r\n\t// get current position with findIndex\r\n\tconst currentIndex = currentTiles.findIndex( tile => tile.id === thisTile.id) + 1; // otherwise zero index\r\n\t// check for empty spaces\r\n\tconst root = Math.sqrt(currentTiles.length); // get width of rows (always 3x3, 4x4 etc.)\r\n\t// status obj to be filled by promisified checking functions\r\n\tlet movementStatuses = {\r\n\t\t'top': {\r\n\t\t\t'allow': false,\r\n\t\t\t'index': false,\r\n\t\t},\r\n\t\t'bottom': {\r\n\t\t\t'allow': false,\r\n\t\t\t'index': false,\r\n\t\t},\r\n\t\t'left': {\r\n\t\t\t'allow': false,\r\n\t\t\t'index': false,\r\n\t\t},\r\n\t\t'right': {\r\n\t\t\t'allow': false,\r\n\t\t\t'index': false,\r\n\t\t},\r\n\t}\r\n\t\r\n\t// try one tile above (basically go forward by width of rows unless that takes you off the grid)\r\n\tlet checkTopPromise = new Promise(function(resolve) {\r\n\t\tresolve(isSpaceFree((currentIndex - root) >= 1 ? currentIndex - root : false));\r\n\t})\r\n\t.then( (results) => {\r\n\t\tmovementStatuses.top.allow = results.result;\r\n\t\tmovementStatuses.top.index = results.index;\r\n\t})\r\n\t.catch( err => console.error(err));\r\n\t\r\n\t// try one tile below (basically go backwards by width of rows unless that takes you off the grid)\r\n\tlet checkBottomPromise = new Promise(function(resolve) {\r\n\t\tresolve(isSpaceFree((currentIndex + root) <= currentTiles.length ? currentIndex + root : false));\r\n\t})\r\n\t.then( (results) => {\r\n\t\tmovementStatuses.bottom.allow = results.result;\r\n\t\tmovementStatuses.bottom.index = results.index;\r\n\t})\r\n\t.catch( err => console.error(err));\r\n\t\r\n\t// try one tile to the left\r\n\tlet checkLeftPromise = new Promise(function(resolve) {\r\n\t\tlet leftTile = false; // default\r\n\t\t// prevent checking past lowest\r\n\t\tif ((currentIndex - 1) >= 1) {\r\n\t\t\tleftTile = currentIndex - 1;\r\n\t\t\t// don't allow wrap!!!!\r\n\t\t\tif (!recursiveFindLowest(currentIndex, currentTiles)) {\r\n\t\t\t\t\tleftTile = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve(isSpaceFree(leftTile));\r\n\t})\r\n\t.then( (results) => {\r\n\t\tmovementStatuses.left.allow = results.result;\r\n\t\tmovementStatuses.left.index = results.index;\r\n\t})\r\n\t.catch( err => console.error(err));\r\n\t\r\n\t// try one tile to the right\r\n\tlet checkRightPromise = new Promise(function(resolve) {\r\n\t\tlet rightTile = false; // default\r\n\t\t// prevent checking past highest\r\n\t\tif ((currentIndex + 1) <= currentTiles.length) {\r\n\t\t\trightTile = currentIndex + 1;\r\n\t\t\t// don't allow wrap!!!!\r\n\t\t\tif (!recursiveFindHighest(currentIndex, currentTiles)) {\r\n\t\t\t\t\trightTile = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresolve(isSpaceFree(rightTile));\r\n\t})\r\n\t.then( (results) => {\r\n\t\tmovementStatuses.right.allow = results.result;\r\n\t\tmovementStatuses.right.index = results.index;\r\n\t})\r\n\t.catch( err => console.error(err));\r\n\t\r\n\t// now try the available direction!\r\n\tPromise.all([checkTopPromise, checkBottomPromise, checkLeftPromise, checkRightPromise]).then(() => {\r\n\t\t// loop over movement status object to try moving\r\n\t\tif (Object.keys(movementStatuses).length > 0 && movementStatuses.constructor === Object) {\r\n\t\t\tfor (const property in movementStatuses) {\r\n\t\t\t\tif (movementStatuses[property] && movementStatuses[property].allow === true) {\r\n\t\t\t\t\t// trigger tile swap!\r\n\t\t\t\t\tswapTiles(currentIndex, movementStatuses[property].index); // current tile index + tile index to swap with\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n}\r\n\r\n// kick off functionality\r\nwindow.addEventListener('load', () => {\r\n\t// init required vars\r\n\tconst startTiles = [...document.querySelectorAll('.tile')];\r\n\tlet memory = [];\r\n\tconst tileContainer = document.querySelector('.tile-container');\r\n\tconst startButton = document.getElementById('startButton');\r\n\tconst resetButton = document.getElementById('resetButton');\r\n\t// set background image positions\r\n\tsetImagePositions(startTiles);\r\n\t// tiles loop\r\n\tstartTiles.forEach( (tile) => {\r\n\t\ttile.id = guidGenerator(); // give IDs\r\n\t\t// add tile click listener\r\n\t\ttile.addEventListener('click', (e) => {\r\n\t\t\tif (!e.target.classList.contains('open')) {\r\n\t\t\t\tconst currentTiles = [...document.querySelectorAll('.tile')];\r\n\t\t\t\t// trigger tile moving to open space\r\n\t\t\t\ttriggerTileMovement(e.target, currentTiles);\r\n\t\t\t\t// check if puzzle now complete\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tif (puzzleCompleteCheck(memory) && !tileContainer.classList.contains('complete')) {\r\n\t\t\t\t\t\talert('Congratulations, you did it! 👏 🥳 🍾');\r\n\t\t\t\t\t\ttileContainer.classList.add('complete');\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 1000);\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\t// set memory\r\n\tmemory = setMemory(startTiles);\r\n\t// button click listeners\r\n\t// start\r\n\tstartButton.addEventListener('click', (e) => {\r\n\t\tif (!startButton.hasAttribute('disabled')) {\r\n\t\t\tshuffleItems(tileContainer);\r\n\t\t\tsetOpenTile(startTiles);\r\n\t\t\tstartButton.setAttribute('disabled', true);\r\n\t\t}\r\n\t\tif (resetButton.hasAttribute('disabled')) {\r\n\t\t\tresetButton.removeAttribute('disabled');\r\n\t\t}\r\n\t\ttileContainer.classList.remove('complete');\r\n\t});\r\n\t// reset\r\n\tresetButton.addEventListener('click', (e) => {\r\n\t\tconst currentTiles = [...document.querySelectorAll('.tile')];\r\n\t\tif (!resetButton.hasAttribute('disabled')) {\r\n\t\t\tresetGrid(startTiles, tileContainer);\r\n\t\t\tresetButton.setAttribute('disabled', true);\r\n\t\t}\r\n\t\tif (startButton.hasAttribute('disabled')) {\r\n\t\t\tstartButton.removeAttribute('disabled');\r\n\t\t}\r\n\t\ttileContainer.classList.add('complete');\r\n\t});\r\n}, false);\r\n"]}